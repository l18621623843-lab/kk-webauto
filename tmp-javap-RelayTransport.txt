Compiled from "RelayTransport.java"
public class io.libp2p.protocol.circuit.RelayTransport implements io.libp2p.core.transport.Transport,io.libp2p.protocol.circuit.HostConsumer {
  private io.libp2p.core.Host us;
  private final java.util.Map<io.libp2p.core.PeerId, io.libp2p.protocol.circuit.RelayTransport$RelayState> listeners;
  private final java.util.Map<io.libp2p.core.multiformats.Multiaddr, io.libp2p.core.Stream> dials;
  private final java.util.function.Function<io.libp2p.core.Host, java.util.List<io.libp2p.protocol.circuit.RelayTransport$CandidateRelay>> candidateRelays;
  private final io.libp2p.protocol.circuit.CircuitHopProtocol$Binding hop;
  private final io.libp2p.protocol.circuit.CircuitStopProtocol$Binding stop;
  public final io.libp2p.transport.ConnectionUpgrader upgrader;
  private final java.util.concurrent.atomic.AtomicInteger relayCount;
  private final java.util.concurrent.ScheduledExecutorService runner;
  public io.libp2p.protocol.circuit.RelayTransport(io.libp2p.protocol.circuit.CircuitHopProtocol$Binding, io.libp2p.protocol.circuit.CircuitStopProtocol$Binding, io.libp2p.transport.ConnectionUpgrader, java.util.function.Function<io.libp2p.core.Host, java.util.List<io.libp2p.protocol.circuit.RelayTransport$CandidateRelay>>, java.util.concurrent.ScheduledExecutorService);
  public void setHost(io.libp2p.core.Host);
  public void setRelayCount(int);
  public int getActiveConnections();
  public int getActiveListeners();
  public java.util.concurrent.CompletableFuture<kotlin.Unit> close();
  public java.util.concurrent.CompletableFuture<io.libp2p.core.Connection> dial(io.libp2p.core.multiformats.Multiaddr, io.libp2p.core.ConnectionHandler, io.libp2p.core.ChannelVisitor<io.libp2p.core.P2PChannel>);
  public static java.util.concurrent.CompletableFuture<io.libp2p.core.Connection> upgradeStream(io.libp2p.core.Stream, boolean, io.libp2p.transport.ConnectionUpgrader, io.libp2p.core.transport.Transport, io.libp2p.core.PeerId, io.libp2p.core.ConnectionHandler);
  public boolean handles(io.libp2p.core.multiformats.Multiaddr);
  public void initialize();
  public void ensureEnoughCurrentRelays();
  public java.util.concurrent.CompletableFuture<kotlin.Unit> listen(io.libp2p.core.multiformats.Multiaddr, io.libp2p.core.ConnectionHandler, io.libp2p.core.ChannelVisitor<io.libp2p.core.P2PChannel>);
  public java.util.List<io.libp2p.core.multiformats.Multiaddr> listenAddresses();
  public java.util.concurrent.CompletableFuture<kotlin.Unit> unlisten(io.libp2p.core.multiformats.Multiaddr);
  private java.util.stream.Stream lambda$listenAddresses$4(java.util.Map$Entry);
  private io.libp2p.core.multiformats.Multiaddr lambda$listenAddresses$3(java.util.Map$Entry, io.libp2p.core.multiformats.Multiaddr);
  private static kotlin.Unit lambda$listen$2(io.libp2p.protocol.circuit.CircuitHopProtocol$Reservation);
  private kotlin.Unit lambda$close$1(java.lang.Void);
  private static java.util.concurrent.CompletableFuture[] lambda$close$0(int);
}
